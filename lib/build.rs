use cbindgen::{self, Config, Language};
use built;

use std::{env, path::PathBuf};

fn main() {
    // Generates built file for aquiring built info in programm
    built::write_built_file().expect("Failed to acquire build-time information");

    // Generating header file for plugins and launcher to link against
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    let config = if let Ok(conf) = Config::from_file("cbindgen.toml") {
        conf
    } else {
        println!("cargo:warning=cbindgen.toml not found (or corrupted) in lib folder, building with defaults");
        let mut conf = Config::default();
        conf.language = Language::C;
        conf.header = Some("/* This file was generated under fallback default settings. Please readd the /lib/cbindgen.toml */\n/* datarace is licensed under GNU v3 */".to_string());
        conf.autogen_warning = Some("/* This file is automatically generated during build process through cbindgen. Don't modify this manually! */".to_string());
        conf.no_includes = false;

        conf
    };
    

    // There should be a more elgant way to get the same name as the libary being build
    let lib_name = if env::var("CARGO_CFG_TARGET_OS").unwrap() == "linux" {
        "libdatarace"
    } else {
        "datarace"
    }.to_string();
    
    let output = PathBuf::from(env::var("OUT_DIR").unwrap()).join("../../..").canonicalize().unwrap().join(lib_name + ".h");

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_config(config)
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(output);
}
